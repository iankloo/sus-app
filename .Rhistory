solve(mat) * vec
solve(mat) * mat
solve(mat) %*% vec
out <- solve(mat) %*% vec
out * mat[,1]
out * mat[1,]
mat[1,]
vec <- matrix(c(10,5,7,4),4,1)
vec
out <- solve(mat) %*% vec
out
out * mat[1,]
out * mat[1,]
out %*% mat[1,]
solve(mat) %*% vec
3*1.2477876
3*1.2477876 + 4*1.0176991 + 5*.8849558 - 2.2389381
c(10,5,7,4) * mat[1,]
sum(c(10,5,7,4) * mat[1,])
mat[1,]
c(10,5,7,4)
out <- solve(mat) %*% vec
sum(out * mat[1,])
sum(out * mat[2,])
sum(out * mat[1,])
5*.8849558
out
a <- matrix(1:12, nrow=4)
b <- matrix(1:15, nrow=3)
a
b
c <- a %*% b
c[3,2]
a[3,] * b[,2]
sum(a[3,] * b[,2])
?crossprod
tt <- seq(0, 3.4, len = n)
#from their practice
g <- 9.8
n <- 25
tt <- seq(0, 3.4, len = n)
f <- 56.67
f <- 56.67 - .5*g*tt^2
y <- f + rnorm(n, sd = 1)
y
plot(x, y)
#from their practice
g <- 9.8
n <- 25
tt <- seq(0, 3.4, len = n)
f <- 56.67 - .5*g*tt^2
y <- f + rnorm(n, sd = 1)
plot(tt), y)
plot(tt, y)
lines(tt, f, col = 2)
rss <- function(beta0, beta1, beta2){
r <- y - (beta0+beta1*tt+beta2*tt^2)
sum(r^2)
}
beta2s <- seq(-10,0,len = 100)
r <- sapply(beta2s, rss, beta0 = 55, beta1 = 0)
plot(beta2s, r, type = 'l')
r <- sapply(beta2s, rss, beta0 = 65, beta1 = 0)
plot(beta2s, r, type = 'l')
mod <- lm(y ~ tt*tt^2)
summary(mod)
tt2 <- tt^2
mod <- lm(y ~ tt+tt^2)
summary(mod)
tt2 <- tt^2
mod <- lm(y ~ tt+tt2)
summary(mod)
x <- cbind(1, tt, tt^2)
x
beta <- matrix(c(55,0,5), 3, 1)
beta
x %*% beta
#resids
y - x %*% beta
#resids
r <- y - x %*% beta
r
RSS <- t(r) %*% r
RSS
#same as
rss(55,0,5)
#special function in R to do all this
crossprod(r)
beta
#get least squares estimates
betahat <_ t(x) %*% x
#get least squares estimates
betahat <- t(x) %*% x
#get least squares estimates
betahat <- solve(t(x) %*% x) %*% t(x) %*% y
betahat
#simpler notation
betahat <- solve(crossprod(x)) %*% crossprod(x, y)
betahat
QR <- qr(x)
Q <- qr.Q(QR)
R <- qr.R(QR)
backsolve(R, crossprod(Q, y))
qr.Q
QR <- qr(x)
?qr
x <- matrix(c(1,1,1,1,0,0,1,1),nrow=4)
rownames(x) <- c("a","a","b","b")
x
beta <- c(5, 2)
sub <- x[1:2,]
sub
sub %*% beta
sub <- x[2:4,]
sub %*% beta
sub <- x[3:4,]
sub %*% beta
x <- matrix(c(1,1,1,1,1,1,0,0,1,1,0,0,0,0,0,0,1,1),nrow=6)
rownames(x) <- c("a","a","b","b","c","c")
x
beta <- c(10,3,-3)
g = 9.8 ## meters per second
h0 = 56.67
v0 = 0
n = 25
tt = seq(0,3.4,len=n) ##time in secs, t is a base function
y = h0 + v0 *tt  - 0.5* g*tt^2 + rnorm(n,sd=1)
X = cbind(1,tt,tt^2)
A = solve(crossprod(X))%*%t(X)
A
A %*% y
-2 * (A %*% y) [3]
set.seed(1)
g = 9.8 ## meters per second
h0 = 56.67
v0 = 0
n = 25
tt = seq(0,3.4,len=n) ##time in secs, t is a base function
y = h0 + v0 *tt  - 0.5* g*tt^2 + rnorm(n,sd=1)
X = cbind(1,tt,tt^2)
A = solve(crossprod(X))%*%t(X)
?replicate
g <- -2 * (A %*% y) [3]
gout <- numeric(length = 100000)
gout <- numeric(length = 100000)
for(i in 1:100000){
y = h0 + v0 *tt  - 0.5* g*tt^2 + rnorm(n,sd=1)
X = cbind(1,tt,tt^2)
A = solve(crossprod(X))%*%t(X)
gout[i] <- -2 * (A %*% y) [3]
}
gout
sd(gout)
mean(gout)
library(UsingR)
x = father.son$fheight
y = father.son$sheight
n = length(y)
set.seed(1)
N =  50
bout <- numeric(length = 10000)
for(i in 1:10000){
index = sample(n,N)
sampledat = father.son[index,]
x = sampledat$fheight
y = sampledat$sheight
bout[i] <-  lm(y~x)$coef
}
warnings()
lm(y~x)$coef
lm(y~x)$coef
lm(y~x)$coef
lm(y~x)$coef[2]
set.seed(1)
N =  50
bout <- numeric(length = 10000)
for(i in 1:10000){
index = sample(n,N)
sampledat = father.son[index,]
x = sampledat$fheight
y = sampledat$sheight
bout[i] <-  lm(y~x)$coef[2]
}
bout
mean(bout)
sd(bout)
mean((Y - mean(Y))*(X-mean(X)))
mean((y - mean(y))*(x-mean(x)))
x = father.son$fheight
y = father.son$sheight
mean((y - mean(y))*(x-mean(x)))
setwd('~/Documents/projects/nag/sus-app/')
library(plumber)
library(servr)
servr::httd('.', port = '80', host = '0.0.0.0', daemon = TRUE)
api_obj <- plumber::plumb('R/plumber.R')
api_obj$run(port = 8080, host = '0.0.0.0')
#---improved munge script for covid data
suppressWarnings({
suppressMessages({
library(data.table)
library(RSQLite)
library(DBI)
library(dplyr)
library(dbplyr)
library(mixdist)
library(extraDistr)
library(jsonlite)
library(geojsonio)
library(sp)
})
})
setwd('~/working/cov_api')
#functions used
rt.func.v2<-function(dat,mean.Weibull=4.8,sd.Weibull=2.3){
r.vals<-numeric(length = (length(dat) - 2))
#get the Weibull parameters from mixdist's weibullpar function
mGT.params<-weibullpar(mean.Weibull, sd.Weibull, loc = 0)
alpha<-mGT.params[2] # called shape in weibullpar, alpha in a discrete Weilbull
beta<-mGT.params[1] # called scale in weibullpar, beta in a discrete Weibull
#the extraDistr package uses an altrnative parameterization of the Weibull (q, beta) from
#Nakagawa and Osaki (1975) where q = exp(-alpha^-beta), so...
q<-exp(-as.numeric(alpha)^(-as.numeric(beta)))
#Discretize Weibull via the extraDistr package's ddweibull function
w<- ddweibull(0:1000, as.numeric(q), as.numeric(beta), log = FALSE)
growth<-diff(dat)
growth<-pmax(growth, 0) # eliminate any erroneous downward shifts in the cumulative counts
#Estimate R(t) from equation (33) of Nishiura and Chowell (2009)
for(k in 2:length(growth)){
r.vals[k-1]<-growth[k]/(sum(growth[1:k]*rev(w[1:k])))
}
#Output the results
return(c(NA, NA, r.vals))
}
covid_db <- dbConnect(RSQLite::SQLite(), 'data/covid_db.sqlite')
#---check if need to update
suppressWarnings({
suppressMessages({
x <- tbl(covid_db, 'counties') %>%
filter(date == max(date, na.rm = TRUE)) %>%
select(date) %>%
collect()
})
})
db_date <- as.Date(x[1][[1]][1])
main <- fread('https://usafactsstatic.blob.core.windows.net/public/data/covid-19/covid_confirmed_usafacts.csv', colClasses = 'character', showProgress = FALSE)
main <- main[countyFIPS != '0']
keep_cols <- grep('V',colnames(main), invert = TRUE)
main <- main[, keep_cols, with=FALSE]
facts_date <- as.Date(colnames(main)[length(colnames(main))], format = '%m/%d/%y')
#---improved munge script for covid data
suppressWarnings({
suppressMessages({
library(data.table)
library(RSQLite)
library(DBI)
library(dplyr)
library(dbplyr)
library(mixdist)
library(extraDistr)
library(jsonlite)
library(geojsonio)
library(sp)
})
})
setwd('~/working/cov_api')
#functions used
rt.func.v2<-function(dat,mean.Weibull=4.8,sd.Weibull=2.3){
r.vals<-numeric(length = (length(dat) - 2))
#get the Weibull parameters from mixdist's weibullpar function
mGT.params<-weibullpar(mean.Weibull, sd.Weibull, loc = 0)
alpha<-mGT.params[2] # called shape in weibullpar, alpha in a discrete Weilbull
beta<-mGT.params[1] # called scale in weibullpar, beta in a discrete Weibull
#the extraDistr package uses an altrnative parameterization of the Weibull (q, beta) from
#Nakagawa and Osaki (1975) where q = exp(-alpha^-beta), so...
q<-exp(-as.numeric(alpha)^(-as.numeric(beta)))
#Discretize Weibull via the extraDistr package's ddweibull function
w<- ddweibull(0:1000, as.numeric(q), as.numeric(beta), log = FALSE)
growth<-diff(dat)
growth<-pmax(growth, 0) # eliminate any erroneous downward shifts in the cumulative counts
#Estimate R(t) from equation (33) of Nishiura and Chowell (2009)
for(k in 2:length(growth)){
r.vals[k-1]<-growth[k]/(sum(growth[1:k]*rev(w[1:k])))
}
#Output the results
return(c(NA, NA, r.vals))
}
covid_db <- dbConnect(RSQLite::SQLite(), 'data/covid_db.sqlite')
#---check if need to update
suppressWarnings({
suppressMessages({
x <- tbl(covid_db, 'counties') %>%
filter(date == max(date, na.rm = TRUE)) %>%
select(date) %>%
collect()
})
})
setwd('~/working/cov_api')
#functions used
rt.func.v2<-function(dat,mean.Weibull=4.8,sd.Weibull=2.3){
r.vals<-numeric(length = (length(dat) - 2))
#get the Weibull parameters from mixdist's weibullpar function
mGT.params<-weibullpar(mean.Weibull, sd.Weibull, loc = 0)
alpha<-mGT.params[2] # called shape in weibullpar, alpha in a discrete Weilbull
beta<-mGT.params[1] # called scale in weibullpar, beta in a discrete Weibull
#the extraDistr package uses an altrnative parameterization of the Weibull (q, beta) from
#Nakagawa and Osaki (1975) where q = exp(-alpha^-beta), so...
q<-exp(-as.numeric(alpha)^(-as.numeric(beta)))
#Discretize Weibull via the extraDistr package's ddweibull function
w<- ddweibull(0:1000, as.numeric(q), as.numeric(beta), log = FALSE)
growth<-diff(dat)
growth<-pmax(growth, 0) # eliminate any erroneous downward shifts in the cumulative counts
#Estimate R(t) from equation (33) of Nishiura and Chowell (2009)
for(k in 2:length(growth)){
r.vals[k-1]<-growth[k]/(sum(growth[1:k]*rev(w[1:k])))
}
#Output the results
return(c(NA, NA, r.vals))
}
covid_db <- dbConnect(RSQLite::SQLite(), 'data/covid_db.sqlite')
#---check if need to update
suppressWarnings({
suppressMessages({
x <- tbl(covid_db, 'counties') %>%
filter(date == max(date, na.rm = TRUE)) %>%
select(date) %>%
collect()
})
})
x <- tbl(covid_db, 'counties') %>%
filter(date == max(date, na.rm = TRUE)) %>%
select(date) %>%
collect()
suppressWarnings({
suppressMessages({
library(data.table)
library(RSQLite)
library(DBI)
library(dplyr)
library(dbplyr)
library(mixdist)
library(extraDistr)
library(jsonlite)
library(geojsonio)
library(sp)
})
})
setwd('~/working/cov_api')
#functions used
rt.func.v2<-function(dat,mean.Weibull=4.8,sd.Weibull=2.3){
r.vals<-numeric(length = (length(dat) - 2))
#get the Weibull parameters from mixdist's weibullpar function
mGT.params<-weibullpar(mean.Weibull, sd.Weibull, loc = 0)
alpha<-mGT.params[2] # called shape in weibullpar, alpha in a discrete Weilbull
beta<-mGT.params[1] # called scale in weibullpar, beta in a discrete Weibull
#the extraDistr package uses an altrnative parameterization of the Weibull (q, beta) from
#Nakagawa and Osaki (1975) where q = exp(-alpha^-beta), so...
q<-exp(-as.numeric(alpha)^(-as.numeric(beta)))
#Discretize Weibull via the extraDistr package's ddweibull function
w<- ddweibull(0:1000, as.numeric(q), as.numeric(beta), log = FALSE)
growth<-diff(dat)
growth<-pmax(growth, 0) # eliminate any erroneous downward shifts in the cumulative counts
#Estimate R(t) from equation (33) of Nishiura and Chowell (2009)
for(k in 2:length(growth)){
r.vals[k-1]<-growth[k]/(sum(growth[1:k]*rev(w[1:k])))
}
#Output the results
return(c(NA, NA, r.vals))
}
suppressWarnings({
suppressMessages({
library(data.table)
library(RSQLite)
library(DBI)
library(dplyr)
library(dbplyr)
library(mixdist)
library(extraDistr)
library(jsonlite)
library(geojsonio)
library(sp)
})
})
setwd('~/working/cov_api')
#functions used
rt.func.v2<-function(dat,mean.Weibull=4.8,sd.Weibull=2.3){
r.vals<-numeric(length = (length(dat) - 2))
#get the Weibull parameters from mixdist's weibullpar function
mGT.params<-weibullpar(mean.Weibull, sd.Weibull, loc = 0)
alpha<-mGT.params[2] # called shape in weibullpar, alpha in a discrete Weilbull
beta<-mGT.params[1] # called scale in weibullpar, beta in a discrete Weibull
#the extraDistr package uses an altrnative parameterization of the Weibull (q, beta) from
#Nakagawa and Osaki (1975) where q = exp(-alpha^-beta), so...
q<-exp(-as.numeric(alpha)^(-as.numeric(beta)))
#Discretize Weibull via the extraDistr package's ddweibull function
w<- ddweibull(0:1000, as.numeric(q), as.numeric(beta), log = FALSE)
growth<-diff(dat)
growth<-pmax(growth, 0) # eliminate any erroneous downward shifts in the cumulative counts
#Estimate R(t) from equation (33) of Nishiura and Chowell (2009)
for(k in 2:length(growth)){
r.vals[k-1]<-growth[k]/(sum(growth[1:k]*rev(w[1:k])))
}
#Output the results
return(c(NA, NA, r.vals))
}
covid_db <- dbConnect(RSQLite::SQLite(), 'data/covid_db.sqlite')
#---check if need to update
suppressWarnings({
suppressMessages({
x <- tbl(covid_db, 'counties') %>%
filter(date == max(date, na.rm = TRUE)) %>%
select(date) %>%
collect()
})
})
db_date <- as.Date(x[1][[1]][1])
main <- fread('https://usafactsstatic.blob.core.windows.net/public/data/covid-19/covid_confirmed_usafacts.csv', colClasses = 'character', showProgress = FALSE)
main <- main[countyFIPS != '0']
keep_cols <- grep('V',colnames(main), invert = TRUE)
main <- main[, keep_cols, with=FALSE]
facts_date <- as.Date(colnames(main)[length(colnames(main))], format = '%m/%d/%y')
#---improved munge script for covid data
suppressWarnings({
suppressMessages({
library(data.table)
library(RSQLite)
library(DBI)
library(dplyr)
library(dbplyr)
library(mixdist)
library(extraDistr)
library(jsonlite)
library(geojsonio)
library(sp)
})
})
setwd('~/working/cov_api')
#functions used
rt.func.v2<-function(dat,mean.Weibull=4.8,sd.Weibull=2.3){
r.vals<-numeric(length = (length(dat) - 2))
#get the Weibull parameters from mixdist's weibullpar function
mGT.params<-weibullpar(mean.Weibull, sd.Weibull, loc = 0)
alpha<-mGT.params[2] # called shape in weibullpar, alpha in a discrete Weilbull
beta<-mGT.params[1] # called scale in weibullpar, beta in a discrete Weibull
#the extraDistr package uses an altrnative parameterization of the Weibull (q, beta) from
#Nakagawa and Osaki (1975) where q = exp(-alpha^-beta), so...
q<-exp(-as.numeric(alpha)^(-as.numeric(beta)))
#Discretize Weibull via the extraDistr package's ddweibull function
w<- ddweibull(0:1000, as.numeric(q), as.numeric(beta), log = FALSE)
growth<-diff(dat)
growth<-pmax(growth, 0) # eliminate any erroneous downward shifts in the cumulative counts
#Estimate R(t) from equation (33) of Nishiura and Chowell (2009)
for(k in 2:length(growth)){
r.vals[k-1]<-growth[k]/(sum(growth[1:k]*rev(w[1:k])))
}
#Output the results
return(c(NA, NA, r.vals))
}
covid_db <- dbConnect(RSQLite::SQLite(), 'data/covid_db.sqlite')
#---check if need to update
suppressWarnings({
suppressMessages({
x <- tbl(covid_db, 'counties') %>%
filter(date == max(date, na.rm = TRUE)) %>%
select(date) %>%
collect()
})
})
db_date <- as.Date(x[1][[1]][1])
main <- fread('https://usafactsstatic.blob.core.windows.net/public/data/covid-19/covid_confirmed_usafacts.csv', colClasses = 'character', showProgress = FALSE)
main <- main[countyFIPS != '0']
keep_cols <- grep('V',colnames(main), invert = TRUE)
main <- main[, keep_cols, with=FALSE]
facts_date <- as.Date(colnames(main)[length(colnames(main))], format = '%m/%d/%y')
library(plumber)
library(servr)
setwd('~/Documents/projects/nag/sus-app/')
setwd('~/Documents/projects/nag/sus-app/')
servr::httd('.', port = '80', host = '0.0.0.0', daemon = TRUE)
api_obj <- plumber::plumb('R/plumber.R')
api_obj$run(port = 8080, host = '0.0.0.0')
t.test(sus_scores)
dat <- fread('~/Downloads/SUS Data for Figure 1 (#49).csv')
#get sus scores
df_sub <- dat[, c(2:ncol(dat)), with = FALSE]
cols <- colnames(df_sub)
df_sub <- data.table(apply(df_sub, 2, as.numeric))
colnames(df_sub) <- cols
odds <- seq(1, ncol(df_sub) - 1, by = 2)
evens <- seq(2, ncol(df_sub), by = 2)
sus_scores <- apply(df_sub, 1, sus_converter, odds, evens)
t.test(sus_scores)
t.test(sus_scores)[1]
out <- t.test(sus_scores)
out$conf.int
out$conf.int[1]
out$conf.int[2]
out$conf.int[[1]]
api_obj <- plumber::plumb('R/plumber.R')
api_obj$run(port = 8080, host = '0.0.0.0')
api_obj$run(port = 8080, host = '0.0.0.0')
x=seq(0,100,by=0.05)
dens <- dst(x, mu=mean(sus_scores), sigma=sd(sus_scores), nu=length(sus_scores), log=FALSE)
t_ci <- t.test(sus_scores)
tdist <- list(sus_scores = sus_scores, ci = t_ci$conf.int, replicates = dens, mean = mean(sus_scores), type = 'tdist')
tdist
api_obj <- plumber::plumb('R/plumber.R')
api_obj$run(port = 8080, host = '0.0.0.0')
api_obj <- plumber::plumb('R/plumber.R')
api_obj$run(port = 8080, host = '0.0.0.0')
api_obj <- plumber::plumb('R/plumber.R')
api_obj$run(port = 8080, host = '0.0.0.0')
